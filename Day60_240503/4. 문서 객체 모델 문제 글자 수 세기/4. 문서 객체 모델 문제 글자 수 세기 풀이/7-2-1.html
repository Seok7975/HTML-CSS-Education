<!DOCTYPE html>
<html>
  <head>
    <title></title>
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const textarea = document.querySelector('textarea')
        const h1 = document.querySelector('h1')

        textarea.addEventListener('keyup', (event) => {
          const length = textarea.value.length
          h1.textContent = `글자 수: ${length}`
        })
      })
    </script>
  </head>
  <body>
    <h1></h1>
    <textarea></textarea>
  </body>
</html>

<!--
  이벤트를 연결하는 방법을 이벤트 모델(event model)이라고 부릅니다.
  07-1에서는 이벤트를 연결할 때 addEventListener() 메소드를 사용했습니다. 이 방법이
  현재 표준으로 사용하고 있는 방법이므로 표준 이벤트 모델이라고 부릅니다.

  document.body.addEventListener('keyup', ()=>{

  })

  과거에는 다음과 같이 문서 객체가 갖고 있는 onOO 으로 시작하는 속성에 함수를 할당해서 이벤트
  를 연결했습니다. 이와 같은 이벤트 연결 방법을 고전 이벤트 모델이라고 부릅니다.

  document.body.onkeyup = (event) => {
                속성
  }

  그리고 고전 이벤트 모델처럼 onOO으로 시작하는 속성을 HTML 요소에 직접 넣어서 이벤트를 연결하는
  것을 인라인 이벤트 모델이라고 부릅니다.

  <script>
    const listener = (event) => {

    }
  </script>
  < body onkeyup = "listener(event)">
  </ body>

  인라인 이벤트 모델은 HTML 요소의 on00 속성에 자바스크립트 코드를 넣는 것입니다. 현재 코드에서는
  listener()라는 함수를 호출하고 있습니다. 이때 on00 속성 내부에서 변수 event를 활용할 수 있습니다.
  이 변수를 listener() 함수의 매개변수로 전달합니다.

  모든 이벤트 모델의 이벤트 리스너는 첫 번째 매개변수로 이벤트 객체(event object)를 받습니다. 이벤트
  객체에는 이벤트와 관련된 정보가 들어있습니다.

  초기의 웹(2000년 이전)은 인라인 이벤트 모델을 일반적으로 사용했습니다. 자바스크립트의 활용이 많지
  않아서 간단한 코드를 넣기에 편리했기 때문입니다. 시간이 지나고 자바스크립트를 더 많이 활용하게 되면서
  고전 이벤트 모델을 많이 사용(2010년 이전)하게 되었습니다. 다만 고전 이벤트 모델은 이벤트 리스너를
  여러 개 연결할 수 있게 되었고 표준 이벤트 모델을 많이 사용(현재)하게 되었습니다. 인라인 이벤트 모델은
  2000년 이후로 거의 사용되지 않아서 알아야 할 필요가 없는 이벤트 모델로 취급받기도 했습니다.

  하지만 최근 프론트엔드 프레임워크들이 인라인 이벤트 모델을 활용하는 형태로 코드를 작성해서 현재에는 
  인라인 이벤트 모델과 표준 이벤트 모델을 많이 사용하고 있습니다.
-->

<!--
  키보드 이벤트
  키보드 이벤트는 다음과 같은 3가지 이벤트가 있다.

  이벤트              설명
  keydown             키가 눌릴 때 실행된다. 키보드를 꾹 누르고 있을 때도, 입력될 때도 실행된다.
  keypress            키가 입력되었을 때 실행된다. 하지만 웹 브라우저에 따라서 아시아권의 문자(한국어,
                        중국어, 일본어를 제대로 처리하지 못하는 문제가 있다.)
  keyup               키보드에서 키가 떨어질 때 실행된다.


-->
<!--
  이벤트들의 관심사항
  이름 대로 keyup은 키가 올라갔을 때 keydown은 키가 내려갔을 때, keypress는 키가 눌렸을 때 발생한다. 그럼
  keydown과 keypress는 같지 않을까?
  같아 보이지만 이 둘은 관심사항이 다르다. keydown(keyup 포함)은 물리적으로 어떤 키가 눌렸는지에 관심이
  있다. 하지만 keypress는 실제로 어떤 값이 입력되는지에 대해 관심이 있다.

  그래서 shift키만 눌렸을 때 실제로 입력되는 내용이 없기 때문에 keypress는 동작하지 않는다.
-->
<!--
    참고    IME 입력문자

  아시아권의 문자를 일반적으로 조합형 문자(IME 입력문자)라고 부른다. 한 글자를 입력하기 위해서는 한국어의
  경우 "안(ㅇ ㅏ ㄴ)"을 누르고, 중국어의 경우 "好(hao)", 일본어의 경우는 "か(ka)"처럼 여러 글자를 조합해야
  한다. 웹 브라우저에 따라서 keypress 이벤트는 조합 중에 발생하기도 발생하지 않기도 하는 문제가 있다.
-->

<!--
  참고로 키보드 이벤트의 문제를 간단하게 살펴보자. 위의 예제를 keydown 이벤트로 구현하면 상황에 따라서 글자
  수를 제대로 세지 못하는 문제가 있다.

  keydown 이벤트
  글자 수 : 1
  ㅋㅋ

  이어서 keypress 이벤트로 구현하면 아시아권의 문자는 공백(띄어쓰기, 줄바꿈 등)이 들어가기 전까지는 글자 수를
  세지 않는다. 아예 keypress 이벤트가 발생하지 않는다.

  keypress 이벤트
  공백이들어가기전까지는글자수를세지않습니다

  사실 keyup 이벤트도 문제가 있습니다. 키가 키보드에서 떨어질 때 발생하므로 특정 키를 꾹 누르고 있으면 글자 수를
  세지 않습니다.

  keyup 이벤트
  ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ

  대표적인 소셜 네트워크 서비스 트위터(Twitter)는 140글자로 글자 수가 제한됩니다. 초기에 keypress 이벤트로 글자
  수를 세었는데, 위와 같은 문제로 아시아권 문자의 글자 수를 제대로 세지 못하는 문제가 발생했습니다. 여러 과정을
  거쳐서 현재는 키보드 이벤트를 사용하지 않고 글자 수를 세고 있는데, 뒤에 7-2-14.html 예제에서 보겠습니다.
-->