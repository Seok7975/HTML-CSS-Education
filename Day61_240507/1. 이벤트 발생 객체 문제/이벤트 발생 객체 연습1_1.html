<!DOCTYPE html>
<html>
    <head>
        <title>        </title>
    </head>
    <body>
        <h1></h1>
        <textarea></textarea>
        <script>
            document.addEventListener('DOMContentLoaded', () => {
                const textarea = document.querySelector('textarea')
                const h1 = document.querySelector('h1')

                textarea.addEventListener('keyup', (e) => {
                    const length = textarea.value.length
                    h1.textContent = `글자 수 : ${length}`
                })
            })
        </script>
    </body>
</html>


<!-- 
이벤트 리스너를 분리하여 관리하는 것은 코드의 가독성과 유지보수성을 향상시키는 좋은 방법

1. 함수 분리
이벤트 핸들러를 별도의 함수로 분리하고, 이벤트 리스너에는 해당 함수를 참조하도록 합니다.
이 방법은 코드를 더 깔끔하게 만들고, 같은 핸들러를 여러 이벤트에 재사용 할 수 있게 해준다

2. 명명 규칙 사용
이벤트 핸들러 함수에 일관된 명명 규칙을 적용하면 함수의 역할을 쉽게 파악할 수 있습니다.  
예를들어, 이벤트 유형과 연관된 요소의 이름을 포함시키는 방식이 있습니다

3. 외부 파일 사용
JavaScript 코드가 많아지면, 이벤트 리스너와 핸들러 함수를 별도의 파일로 분리하여 관리할 수 있습니다.
이렇게 하면 HTML문서가 더 깔끔해지고, JavaScript 코드의 관리도 용이해집니다.

팁을 적용해 리팩토링해보자면
1. 이벤트 핸들러 함수 분리하기
2. 명명 규칙 적용하기
3. 필요하다면, 외부 JavaScript 파일로 분리하기 
-->

<!-- 
이벤트 리스너
이벤트 리스너는 특정 이벤트(클릭, 키보드 입력, 페이지 로딩 등)가 발생할 때마다 반응하도록
대기하는 함수 또는 객체입니다. 즉, 이벤트 리스너는 이벤트를 "듣고"있으며, 해당 이벤트가 발생하면
반응(콜백함수(이벤트 핸들러) 호출)하는 것이다.
다시 말해, 이벤트 핸들러를 등록하는 과정에서 사용

이벤트 핸들러
이벤트가 발생했을 때 실제로 실행되는 함수이다.
즉, 이벤트 리스너에 의해 호출되어 특정 이벤트에 대한 반응을 처리하는 코드
또한, 이벤트가 발생했을 때 수행될 구체적인 작업을 정의한다.
ex) 사용자가 버튼을 클릭했을 때 실해오디어야 할 코드 블록이 이벤트 핸들러에 해당
 -->